<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>BAL: Referencia del Archivo oper.c</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generado por Doxygen 1.5.5 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Página&nbsp;principal</span></a></li>
      <li><a href="pages.html"><span>Páginas&nbsp;relacionadas</span></a></li>
      <li><a href="annotated.html"><span>Estructuras&nbsp;de&nbsp;Datos</span></a></li>
      <li class="current"><a href="files.html"><span>Archivos</span></a></li>
      <li><a href="dirs.html"><span>Directorios</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Referencia del Archivo oper.c</h1>Operaciones básicas, implementación. <a href="#_details">Más...</a>
<p>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;glib.h&gt;</code><br>
<code>#include &quot;<a class="el" href="sp__packcol_8h-source.html">sparse/sp_packcol.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="sp__cds_8h-source.html">sparse/sp_cds.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="utils_8h-source.html">utils.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="oper_8h-source.html">oper.h</a>&quot;</code><br>

<p>
<a href="oper_8c-source.html">Ir al código fuente de este archivo.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Funciones</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oper_8c.html#8bdc34ab9889aa1cad64fcc44dd7a2ec">mult_vec_packcol</a> (<a class="el" href="structsp__packcol.html">sp_packcol</a> *A, double *x, double *y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplica una matriz empaquetada por columna por un vector.  <a href="#8bdc34ab9889aa1cad64fcc44dd7a2ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oper_8c.html#0f9cb665556ffdd8bdb5dfbe861e0d28">mult_vec_packcol_symmetric</a> (<a class="el" href="structsp__packcol.html">sp_packcol</a> *A, double *x, double *y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplica una matriz simétrica empaquetada por columna por un vector.  <a href="#0f9cb665556ffdd8bdb5dfbe861e0d28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oper_8c.html#695a940f46d1c589bfcf8758f7a87f15">mult_vec_cds</a> (<a class="el" href="structsp__cds.html">sp_cds</a> *A, double *x, double *y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplica una matriz en formato CDS por un vector.  <a href="#695a940f46d1c589bfcf8758f7a87f15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsp__cds.html">sp_cds</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oper_8c.html#6ea0383a6eb9a67301225f5f2fee87b4">mult_mat_cds</a> (<a class="el" href="structsp__cds.html">sp_cds</a> *A, <a class="el" href="structsp__cds.html">sp_cds</a> *B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplica dos matrices en formato CDS.  <a href="#6ea0383a6eb9a67301225f5f2fee87b4"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Descripción detallada</h2>
Operaciones básicas, implementación. 
<p>
Este archivo contiene las implementaciones de las funciones que implementan operaciones básicas entre matrices y vectores utilizando estructuras de datos para matrices dispersas. 
<p>Definición en el archivo <a class="el" href="oper_8c-source.html">oper.c</a>.</p>
<hr><h2>Documentación de las funciones</h2>
<a class="anchor" name="6ea0383a6eb9a67301225f5f2fee87b4"></a><!-- doxytag: member="oper.c::mult_mat_cds" ref="6ea0383a6eb9a67301225f5f2fee87b4" args="(sp_cds *A, sp_cds *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsp__cds.html">sp_cds</a> * mult_mat_cds           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsp__cds.html">sp_cds</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsp__cds.html">sp_cds</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplica dos matrices en formato CDS. 
<p>
<dl compact><dt><b>Parámetros:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>Matriz operando izquierdo de la multiplicación </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>Matriz operando derecho de la multiplicación</td></tr>
  </table>
</dl>
Esta operación computa la operación <img class="formulaInl" alt="$C = AB$" src="form_6.png"> y devuelve un puntero a la matriz <code>C</code>.<p>
La implementación de esta operación está dividida en dos etapas claramente diferenciadas: <ol>
<li>
Cálculo anticipado de la estructura de <code>C</code> (cuyo objetivo es equivalente al de una factorización simbólica) </li>
<li>
Cálculo numérico de <code>C</code> </li>
</ol>
<p>
La lógica de ambas etapas está fundamentada en la misma observación que puede hacerse del algoritmo <em>"clásico"</em> de multiplicación de matrices. Recordando nuestra definición de diagonales (el elemento <img class="formulaInl" alt="$a_{ij}$" src="form_7.png"> pertenece a la diagonal <img class="formulaInl" alt="$j-i$" src="form_8.png">) y observando el algoritmo clásico <p class="formulaDsp">
<img class="formulaDsp" alt="\[ c_{ij} = \sum_{k=0}^n a_{ik}b_{kj} \]" src="form_9.png">
<p>
 obtenemos las siguientes conclusiones:<p>
Primero, toda diagonal <code>t</code> de <code>C</code> se verá afectada únicamente por productos de entradas de todo par de diagonales <code>r</code> y <code>s</code> de <code>A</code> y <code>B</code> respectivamente, tales que <code>t = r+s</code>. Para convencernos de esto, basta ver el algoritmo clásico. Vemos que el elemento <img class="formulaInl" alt="$c_{ij}$" src="form_10.png"> (perteneciente a la diagonal <code>(j-i)</code>) se ve afectado por la multiplicación de <img class="formulaInl" alt="$a_{ik}b_{kj}$" src="form_11.png"> para todo <code>k</code>. Es decir, un elemento de la diagonal <code>(k-i)</code> de <code>A</code> y un elemento de la diagonal <code>(j-k)</code> de <code>B</code>. Por lo tanto, como tenemos que <code>(k-i)+(j-k) = j-i</code>, nuestro enunciado es correcto.<p>
Esta observación nos da una pauta de cómo realizar ambas etapas del algoritmo. En particular, para la etapa de cálculo de la estructura del resultado <code>C</code>, podemos afirmar lo siguiente: Si la diagonales <code>r</code> de <code>A</code> y <code>s</code> de <code>B</code> son no vacías (entendiendo por diagonal vacía aquella con cero en todas sus entradas), entonces la diagonal <code>(r+s)</code> de <code>C</code> (si existe) es no vacía.<p>
La acotación "si existe" del enunciado anterior es porque van a haber diagonales que no se van a cruzar en el producto. Basta ver cómo el algoritmo calcula las diagonales máxima y mínima (variables <code>mindiag</code> y <code>maxdiag</code>) antes de comenzar con el cálculo de la estructura.<p>
Con esto tenemos resuelto el cálculo de la estructura de <code>C</code>. Observamos que también será una matriz de banda, pero más diagonales tendrán valores no cero.<p>
Con respecto al cálculo de las entradas de <code>C</code>, hace falta aclarar cómo se multiplican las entradas de las diagonales de <code>A</code> y <code>B</code>. Ya vimos que un elemento de la diagonal de <code>A</code> se multiplicará con uno de <code>B</code>. Pero, ¿cuál con cuál?<p>
Observamos, gracias al algoritmo "clásico", que todo producto de entradas de <code>A</code> y <code>B</code> siempre cumple que la columna de <code>A</code> se corresponde con la misma fila de <code>B</code> (ambas tienen el mismo índice <code>k</code> en el algoritmo). Por lo tanto, dadas dos diagonales <code>r</code> y <code>s</code> de <code>A</code> y <code>B</code> respectivamente, basta encontrar el primer par de elementos que cumplan con esta condición, para que los siguientes pares (avanzando un lugar en cada una de las diagonales) también lo cumpla. Esto es lo que hace el algoritmo en la etapa comentada como la "alineación" de las diagonales a multiplicar. Luego de esto, se hace el producto entrada por entrada.<p>
<dl class="note" compact><dt><b>Nota:</b></dt><dd>La etapa de cálculo de la estructura ejecuta en un tiempo que está en el orden <em>O(A.ndiag+B.ndiag)</em>, mientras que el cálculo numérico ejecuta en un tiempo que está en el orden <em>O(D(A)+D(B))</em>, siendo <code>D(X)</code> la cantidad de entradas (con valor cero o no cero) que componen todas las diagonales no vacías de <code>X</code>. </dd></dl>

<p>Definición en la línea <a class="el" href="oper_8c-source.html#l00205">205</a> del archivo <a class="el" href="oper_8c-source.html">oper.c</a>.</p>

<p>Hace referencia a <a class="el" href="utils_8h-source.html#l00016">BAL_ERROR</a>, <a class="el" href="utils_8c-source.html#l00018">binary_search()</a>, <a class="el" href="sp__cds_8h-source.html#l00073">sp_cds::dx</a>, <a class="el" href="utils_8c-source.html#l00055">insert_sorted()</a>, <a class="el" href="sp__cds_8h-source.html#l00072">sp_cds::maxdiaglength</a>, <a class="el" href="sp__cds_8h-source.html#l00070">sp_cds::ncol</a>, <a class="el" href="sp__cds_8h-source.html#l00071">sp_cds::ndiag</a>, <a class="el" href="sp__cds_8h-source.html#l00069">sp_cds::nrow</a>, y <a class="el" href="sp__cds_8h-source.html#l00074">sp_cds::val</a>.</p>

<p>Referenciado por <a class="el" href="bal_8c-source.html#l00282">bal_mult_mat_cds()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00206"></a>00206 {
<a name="l00207"></a>00207     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n, m, tope, dxl, ka, kb, i, j, k;
<a name="l00208"></a>00208     <span class="keywordtype">int</span> mindiag, maxdiag, diaga, diagb, diag, inia, fina, inib, finb, ja, diff;
<a name="l00209"></a>00209     <a class="code" href="structsp__cds.html" title="Estructura de matriz dispersa CDS.">sp_cds</a>* c;
<a name="l00210"></a>00210 
<a name="l00211"></a>00211     <span class="keywordflow">if</span> (A-&gt;<a class="code" href="structsp__cds.html#683cb5023edac60bd4c25a1c2261f6b0" title="Cantidad de columnas.">ncol</a> != B-&gt;<a class="code" href="structsp__cds.html#742f0fa7433a0985c236c0df1811513a" title="Cantidad de filas.">nrow</a>) {
<a name="l00212"></a>00212         <a class="code" href="utils_8h.html#f9a64ef5874a8560a9067ac3191cced4" title="Función para reportar errores detectados por código de BAL.">BAL_ERROR</a>(<span class="stringliteral">"Las dimensiones de las matrices no permiten su multiplicación"</span>);
<a name="l00213"></a>00213         <span class="keywordflow">return</span> NULL;
<a name="l00214"></a>00214     }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216     c = (<a class="code" href="structsp__cds.html" title="Estructura de matriz dispersa CDS.">sp_cds</a>*)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structsp__cds.html" title="Estructura de matriz dispersa CDS.">sp_cds</a>));
<a name="l00217"></a>00217     c-&gt;<a class="code" href="structsp__cds.html#742f0fa7433a0985c236c0df1811513a" title="Cantidad de filas.">nrow</a> = n = A-&gt;<a class="code" href="structsp__cds.html#742f0fa7433a0985c236c0df1811513a" title="Cantidad de filas.">nrow</a>;
<a name="l00218"></a>00218     c-&gt;<a class="code" href="structsp__cds.html#683cb5023edac60bd4c25a1c2261f6b0" title="Cantidad de columnas.">ncol</a> = m = B-&gt;<a class="code" href="structsp__cds.html#683cb5023edac60bd4c25a1c2261f6b0" title="Cantidad de columnas.">ncol</a>;
<a name="l00219"></a>00219     c-&gt;<a class="code" href="structsp__cds.html#86bfcae3996588048cb6c973cd223b39" title="El largo de la diagonal más larga.">maxdiaglength</a> = MIN(n, m);
<a name="l00220"></a>00220     tope = m + n - 1; <span class="comment">/* Cantidad máxima de diagonales */</span>
<a name="l00221"></a>00221     c-&gt;<a class="code" href="structsp__cds.html#cb3c554898b39c854cc3d26f657ce0fd" title="Arreglo de índices de diagonal.">dx</a> = (<span class="keywordtype">int</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * tope);
<a name="l00222"></a>00222 
<a name="l00223"></a>00223     <span class="comment">/* Calcula las diagonales que tendrán datos en el resultado */</span>
<a name="l00224"></a>00224     mindiag = 1 - n;
<a name="l00225"></a>00225     maxdiag = m - 1;
<a name="l00226"></a>00226     dxl = 0;
<a name="l00227"></a>00227     <span class="keywordflow">for</span> (ka=0; ka &lt; A-&gt;<a class="code" href="structsp__cds.html#f2a5117c4b15e96598d0a75a645cdb3f" title="Cantidad de diagonales con al menos una entrada no cero.">ndiag</a>; ++ka) {       <span class="comment">/* Por cada diagonal con datos en A */</span>
<a name="l00228"></a>00228         diaga = A-&gt;<a class="code" href="structsp__cds.html#cb3c554898b39c854cc3d26f657ce0fd" title="Arreglo de índices de diagonal.">dx</a>[ka];
<a name="l00229"></a>00229         <span class="keywordflow">for</span> (kb=0; kb &lt; B-&gt;<a class="code" href="structsp__cds.html#f2a5117c4b15e96598d0a75a645cdb3f" title="Cantidad de diagonales con al menos una entrada no cero.">ndiag</a>; ++kb) {   <span class="comment">/* Por cada diagonal con datos en B */</span>
<a name="l00230"></a>00230             diagb = B-&gt;<a class="code" href="structsp__cds.html#cb3c554898b39c854cc3d26f657ce0fd" title="Arreglo de índices de diagonal.">dx</a>[kb];
<a name="l00231"></a>00231 
<a name="l00232"></a>00232             diag = diaga + diagb;           <span class="comment">/* Diagonal en C que tendrá datos */</span>
<a name="l00233"></a>00233             <span class="keywordflow">if</span> (diag &gt;= mindiag &amp;&amp; diag &lt;= maxdiag) {
<a name="l00234"></a>00234                 <span class="keywordflow">if</span> (<a class="code" href="utils_8c.html#68d639af59cdb0c547839cb44aa06854" title="Busca un elemento en el array mediante bipartición.">binary_search</a>(c-&gt;<a class="code" href="structsp__cds.html#cb3c554898b39c854cc3d26f657ce0fd" title="Arreglo de índices de diagonal.">dx</a>, dxl, diag) == -1) {
<a name="l00235"></a>00235                     <a class="code" href="utils_8c.html#e92b7a18bc3552887809bbac1b732152" title="Inserta un elemento en un arreglo ordenado.">insert_sorted</a>(c-&gt;<a class="code" href="structsp__cds.html#cb3c554898b39c854cc3d26f657ce0fd" title="Arreglo de índices de diagonal.">dx</a>, dxl - 1, diag);
<a name="l00236"></a>00236                     ++dxl;
<a name="l00237"></a>00237                 }
<a name="l00238"></a>00238             }
<a name="l00239"></a>00239         }
<a name="l00240"></a>00240     }
<a name="l00241"></a>00241 
<a name="l00242"></a>00242     <span class="comment">/* Inicializa c-&gt;val */</span>
<a name="l00243"></a>00243     c-&gt;<a class="code" href="structsp__cds.html#f2a5117c4b15e96598d0a75a645cdb3f" title="Cantidad de diagonales con al menos una entrada no cero.">ndiag</a> = dxl;
<a name="l00244"></a>00244     c-&gt;<a class="code" href="structsp__cds.html#4a43be75b65bb01b343c8d3c144b7194" title="Matriz de valores. Cada fila es una diagonal.">val</a> = (<span class="keywordtype">double</span>**)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>*) * dxl);
<a name="l00245"></a>00245     <span class="keywordflow">for</span> (i=0; i &lt; dxl; ++i) {
<a name="l00246"></a>00246         c-&gt;<a class="code" href="structsp__cds.html#4a43be75b65bb01b343c8d3c144b7194" title="Matriz de valores. Cada fila es una diagonal.">val</a>[i] = (<span class="keywordtype">double</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * c-&gt;<a class="code" href="structsp__cds.html#86bfcae3996588048cb6c973cd223b39" title="El largo de la diagonal más larga.">maxdiaglength</a>);
<a name="l00247"></a>00247         <span class="keywordflow">for</span> (j=0; j &lt; c-&gt;<a class="code" href="structsp__cds.html#86bfcae3996588048cb6c973cd223b39" title="El largo de la diagonal más larga.">maxdiaglength</a>; ++j)
<a name="l00248"></a>00248             c-&gt;<a class="code" href="structsp__cds.html#4a43be75b65bb01b343c8d3c144b7194" title="Matriz de valores. Cada fila es una diagonal.">val</a>[i][j] = 0;
<a name="l00249"></a>00249     }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251     <span class="comment">/* Calcula los valores de c */</span>
<a name="l00252"></a>00252     <span class="keywordflow">for</span> (ka=0; ka &lt; A-&gt;<a class="code" href="structsp__cds.html#f2a5117c4b15e96598d0a75a645cdb3f" title="Cantidad de diagonales con al menos una entrada no cero.">ndiag</a>; ++ka) {       <span class="comment">/* Por cada diagonal con datos en A */</span>
<a name="l00253"></a>00253         diaga = A-&gt;<a class="code" href="structsp__cds.html#cb3c554898b39c854cc3d26f657ce0fd" title="Arreglo de índices de diagonal.">dx</a>[ka];
<a name="l00254"></a>00254         <span class="keywordflow">for</span> (kb=0; kb &lt; B-&gt;<a class="code" href="structsp__cds.html#f2a5117c4b15e96598d0a75a645cdb3f" title="Cantidad de diagonales con al menos una entrada no cero.">ndiag</a>; ++kb) {   <span class="comment">/* Por cada diagonal con datos en B */</span>
<a name="l00255"></a>00255             diagb = B-&gt;<a class="code" href="structsp__cds.html#cb3c554898b39c854cc3d26f657ce0fd" title="Arreglo de índices de diagonal.">dx</a>[kb];
<a name="l00256"></a>00256 
<a name="l00257"></a>00257             diag = diaga + diagb;
<a name="l00258"></a>00258             k = <a class="code" href="utils_8c.html#68d639af59cdb0c547839cb44aa06854" title="Busca un elemento en el array mediante bipartición.">binary_search</a>(c-&gt;<a class="code" href="structsp__cds.html#cb3c554898b39c854cc3d26f657ce0fd" title="Arreglo de índices de diagonal.">dx</a>, dxl, diag);
<a name="l00259"></a>00259 
<a name="l00260"></a>00260             inia = MAX(0, -diaga);
<a name="l00261"></a>00261             fina = A-&gt;<a class="code" href="structsp__cds.html#86bfcae3996588048cb6c973cd223b39" title="El largo de la diagonal más larga.">maxdiaglength</a> - MAX(0, diaga);
<a name="l00262"></a>00262             inib = MAX(0, -diagb);
<a name="l00263"></a>00263             finb = B-&gt;<a class="code" href="structsp__cds.html#86bfcae3996588048cb6c973cd223b39" title="El largo de la diagonal más larga.">maxdiaglength</a> - MAX(0, diagb);
<a name="l00264"></a>00264 
<a name="l00265"></a>00265             <span class="comment">/* Alinea las diagonales para multiplicar */</span>
<a name="l00266"></a>00266             ja = A-&gt;<a class="code" href="structsp__cds.html#cb3c554898b39c854cc3d26f657ce0fd" title="Arreglo de índices de diagonal.">dx</a>[ka] + inia;
<a name="l00267"></a>00267             diff = ja - inib;
<a name="l00268"></a>00268             <span class="keywordflow">if</span> (diff &gt; 0)
<a name="l00269"></a>00269                 inib += diff;
<a name="l00270"></a>00270             <span class="keywordflow">else</span>
<a name="l00271"></a>00271                 inia -= diff;
<a name="l00272"></a>00272 
<a name="l00273"></a>00273             <span class="keywordflow">for</span> (i=inia,j=inib; i &lt; fina &amp;&amp; j &lt; finb; ++i, ++j)
<a name="l00274"></a>00274                 c-&gt;<a class="code" href="structsp__cds.html#4a43be75b65bb01b343c8d3c144b7194" title="Matriz de valores. Cada fila es una diagonal.">val</a>[k][i] += ( A-&gt;<a class="code" href="structsp__cds.html#4a43be75b65bb01b343c8d3c144b7194" title="Matriz de valores. Cada fila es una diagonal.">val</a>[ka][i] * B-&gt;<a class="code" href="structsp__cds.html#4a43be75b65bb01b343c8d3c144b7194" title="Matriz de valores. Cada fila es una diagonal.">val</a>[kb][j] );
<a name="l00275"></a>00275         }
<a name="l00276"></a>00276     }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278     <span class="keywordflow">return</span> c;
<a name="l00279"></a>00279 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="695a940f46d1c589bfcf8758f7a87f15"></a><!-- doxytag: member="oper.c::mult_vec_cds" ref="695a940f46d1c589bfcf8758f7a87f15" args="(sp_cds *A, double *x, double *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mult_vec_cds           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsp__cds.html">sp_cds</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplica una matriz en formato CDS por un vector. 
<p>
<dl compact><dt><b>Parámetros:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>ENTRADA: Matriz dispersa en formato CDS </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>ENTRADA: Vector a multiplicar </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>SALIDA: Resultado de la multiplicación</td></tr>
  </table>
</dl>
Esta función realiza la operación <img class="formulaInl" alt="$y = Ax$" src="form_5.png"> siendo <code>A</code> una matriz en formato CDS.<p>
Teniendo en cuenta que cada elemento de una diagonal de <code>A</code> solo afecta una entrada del resultado <code>y</code>, la estrategia es recorrer la matriz por diagonales (aprovechando la estructura CDS) y, para cada elemento de la diagonal, actualizar cada entrada de <code>y</code> según cómo la afecta el elemento procesado. Luego de recorrer todas las diagonales, el vector <code>y</code> contiene el resultado esperado.<p>
Dado que una fila de <code>val</code> puede tener entradas que ni siquiera representan un elemento válido en <code>A</code>, es importante ver desde dónde y hasta dónde se recorre cada fila en <code>val</code>. Aprovechando la alineación que se le da a cada diagonal dentro de la estructura (a la izquierda si es superior y a la derecha si es inferior, ver la descripción de la estructura <a class="el" href="structsp__cds.html" title="Estructura de matriz dispersa CDS.">sp_cds</a>) el algoritmo precalcula el rango de entradas donde hay datos válidos antes de iterar en los elementos de la diagonal, es decir, antes de comenzar con el loop interior.<p>
<dl class="note" compact><dt><b>Nota:</b></dt><dd>Es importante notar que las entradas del vector <code>y</code> se van construyendo a medida que se van recorriendo las diagonales de <code>A</code>, y no son construidas en un único paso, como es el caso del algoritmo del producto de matriz-vector clásico.<p>
Este algoritmo ejecuta en un tiempo que está en el orden <em>O(D(A))</em>, siendo <code>D(A)</code> la cantidad de entradas (con valor cero o no cero) que componen todas las diagonales no vacías de <code>A</code>.</dd></dl>
<dl class="warning" compact><dt><b>Atención:</b></dt><dd>Esta función no reserva memoria. El vector <code>y</code> ya debe estar inicializado en el tamaño correcto antes de llamar a esta función. </dd></dl>

<p>Definición en la línea <a class="el" href="oper_8c-source.html#l00130">130</a> del archivo <a class="el" href="oper_8c-source.html">oper.c</a>.</p>

<p>Hace referencia a <a class="el" href="sp__cds_8h-source.html#l00073">sp_cds::dx</a>, <a class="el" href="sp__cds_8h-source.html#l00072">sp_cds::maxdiaglength</a>, <a class="el" href="sp__cds_8h-source.html#l00071">sp_cds::ndiag</a>, <a class="el" href="sp__cds_8h-source.html#l00069">sp_cds::nrow</a>, y <a class="el" href="sp__cds_8h-source.html#l00074">sp_cds::val</a>.</p>

<p>Referenciado por <a class="el" href="bal_8c-source.html#l00272">bal_mult_vec_cds()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00131"></a>00131 {
<a name="l00132"></a>00132     <span class="keywordtype">int</span> i, j, k, diag, ini, fin;
<a name="l00133"></a>00133 
<a name="l00134"></a>00134     <span class="comment">/* Inicializa vector y */</span>
<a name="l00135"></a>00135     <span class="keywordflow">for</span> (j = 0; j &lt; A-&gt;<a class="code" href="structsp__cds.html#742f0fa7433a0985c236c0df1811513a" title="Cantidad de filas.">nrow</a>; ++j)
<a name="l00136"></a>00136         y[j] = 0;
<a name="l00137"></a>00137 
<a name="l00138"></a>00138     <span class="keywordflow">for</span> (k=0; k &lt; A-&gt;<a class="code" href="structsp__cds.html#f2a5117c4b15e96598d0a75a645cdb3f" title="Cantidad de diagonales con al menos una entrada no cero.">ndiag</a>; ++k) {      <span class="comment">/* Por cada diagonal no vacía en A */</span>
<a name="l00139"></a>00139         diag = A-&gt;<a class="code" href="structsp__cds.html#cb3c554898b39c854cc3d26f657ce0fd" title="Arreglo de índices de diagonal.">dx</a>[k];
<a name="l00140"></a>00140 
<a name="l00141"></a>00141         <span class="comment">/* Calcula inicio y fin de la diagonal en la fila de val */</span>
<a name="l00142"></a>00142         ini = MAX(0, -diag);
<a name="l00143"></a>00143         fin = A-&gt;<a class="code" href="structsp__cds.html#86bfcae3996588048cb6c973cd223b39" title="El largo de la diagonal más larga.">maxdiaglength</a> - MAX(0, diag);
<a name="l00144"></a>00144 
<a name="l00145"></a>00145         <span class="keywordflow">for</span> (i=ini; i &lt; (A-&gt;<a class="code" href="structsp__cds.html#86bfcae3996588048cb6c973cd223b39" title="El largo de la diagonal más larga.">maxdiaglength</a>); ++i) {  <span class="comment">/* Por cada elemento de la diagonal */</span>
<a name="l00146"></a>00146             j = diag + i;
<a name="l00147"></a>00147             y[i] += ( A-&gt;<a class="code" href="structsp__cds.html#4a43be75b65bb01b343c8d3c144b7194" title="Matriz de valores. Cada fila es una diagonal.">val</a>[k][i] * x[j] );
<a name="l00148"></a>00148         }
<a name="l00149"></a>00149     }
<a name="l00150"></a>00150 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8bdc34ab9889aa1cad64fcc44dd7a2ec"></a><!-- doxytag: member="oper.c::mult_vec_packcol" ref="8bdc34ab9889aa1cad64fcc44dd7a2ec" args="(sp_packcol *A, double *x, double *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mult_vec_packcol           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsp__packcol.html">sp_packcol</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplica una matriz empaquetada por columna por un vector. 
<p>
<dl compact><dt><b>Parámetros:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>ENTRADA: Matriz dispersa empaquetada por columna simétrica </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>ENTRADA: Vector a multiplicar </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>SALIDA: Resultado de la multiplicación</td></tr>
  </table>
</dl>
Esta función realiza la operación <img class="formulaInl" alt="$y = Ax$" src="form_5.png"> siendo <code>A</code> una matriz empaquetada por columna.<p>
<dl class="note" compact><dt><b>Nota:</b></dt><dd>La estructura en memoria es tal como la generada por la función <a class="el" href="sp__packcol_8c.html#729d10ec6867249f9b58ceb2683a3318" title="Genera una instancia de la matriz mat en formato empaquetado por columna.">coord2packcol()</a></dd></dl>
<dl class="warning" compact><dt><b>Atención:</b></dt><dd>Esta función no reserva memoria. El vector <code>y</code> ya debe estar inicializado en el tamaño correcto antes de llamar a esta función. </dd></dl>

<p>Definición en la línea <a class="el" href="oper_8c-source.html#l00032">32</a> del archivo <a class="el" href="oper_8c-source.html">oper.c</a>.</p>

<p>Hace referencia a <a class="el" href="sp__packcol_8h-source.html#l00026">sp_packcol::colp</a>, <a class="el" href="sp__packcol_8h-source.html#l00024">sp_packcol::ncol</a>, <a class="el" href="sp__packcol_8h-source.html#l00023">sp_packcol::nrow</a>, <a class="el" href="sp__packcol_8h-source.html#l00027">sp_packcol::rx</a>, y <a class="el" href="sp__packcol_8h-source.html#l00028">sp_packcol::val</a>.</p>

<p>Referenciado por <a class="el" href="bal_8c-source.html#l00132">bal_mult_vec_packcol()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00033"></a>00033 {
<a name="l00034"></a>00034     <span class="keywordtype">int</span> i, ii, j;
<a name="l00035"></a>00035 
<a name="l00036"></a>00036     <span class="comment">/* Inicializa vector y */</span>
<a name="l00037"></a>00037     <span class="keywordflow">for</span> (j = 0; j &lt; A-&gt;<a class="code" href="structsp__packcol.html#2e12b2881843b0ff8191f0654570a748" title="Cantidad de filas de la matriz.">nrow</a>; ++j)
<a name="l00038"></a>00038         y[j] = 0;
<a name="l00039"></a>00039 
<a name="l00040"></a>00040     <span class="keywordflow">for</span>(j = 0; j &lt; A-&gt;<a class="code" href="structsp__packcol.html#2cc24559101ca3783f1949c8eebacd7c" title="Cantidad de columnas de la matriz.">ncol</a>; ++j) {
<a name="l00041"></a>00041         <span class="keywordflow">for</span>(ii = A-&gt;<a class="code" href="structsp__packcol.html#c9a9e31c6b9c1416fff29944568ea18f" title="Arreglo de punteros a los inicios de las columnas.">colp</a>[j]; ii &lt; A-&gt;colp[j+1]; ++ii) {
<a name="l00042"></a>00042             i = A-&gt;<a class="code" href="structsp__packcol.html#536659b700c3b21fd5d6cf8538c82b6f" title="Arreglo de indices de fila.">rx</a>[ii];
<a name="l00043"></a>00043             y[i] += ( x[j] * A-&gt;<a class="code" href="structsp__packcol.html#6315b3a8ee78ac66aaae5ba79bda252e" title="Arreglo de valores por debajo de la diagonal.">val</a>[ii] );
<a name="l00044"></a>00044         }
<a name="l00045"></a>00045     }
<a name="l00046"></a>00046 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0f9cb665556ffdd8bdb5dfbe861e0d28"></a><!-- doxytag: member="oper.c::mult_vec_packcol_symmetric" ref="0f9cb665556ffdd8bdb5dfbe861e0d28" args="(sp_packcol *A, double *x, double *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mult_vec_packcol_symmetric           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsp__packcol.html">sp_packcol</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplica una matriz simétrica empaquetada por columna por un vector. 
<p>
<dl compact><dt><b>Parámetros:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>Matriz dispersa empaquetada por columna simétrica </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Vector a multiplicar </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Resultado de la multiplicación</td></tr>
  </table>
</dl>
Esta función calcula la operación <img class="formulaInl" alt="$y = Ax$" src="form_5.png"> bajo las siguientes consideraciones: <ul>
<li>
La matriz A está guardada con la mejora para matrices simétricas, tal cual lo hace la función <a class="el" href="sp__packcol_8c.html#7d8ea564f906cc721e5de1c4a4f5844b" title="Genera una instancia de la matriz mat en formato empaquetado por columna para matrices...">coord2packcol_symmetric()</a> </li>
<li>
Los vectores <code>x</code> e <code>y</code> tienen <code>A.nrow</code> elementos (Ver definición de la estructura <a class="el" href="structsp__packcol.html" title="Estructura de matriz dispersa empaquetada por columna.">sp_packcol</a>) y ya están inicializados </li>
</ul>
<p>
<dl class="note" compact><dt><b>Nota:</b></dt><dd>Ver el algoritmo 5.1 (sección 5.2 Matrix-vector multiplication) en el paper de Stewart (vea las <a class="el" href="index.html#refsec">referencias</a>).</dd></dl>
<dl class="warning" compact><dt><b>Atención:</b></dt><dd>La implementación sugerida por Stewart tiene un bug: el algoritmo no devuelve el resultado correcto si la diagonal mayor de <code>A</code> contiene ceros. En esta implementación se corrigió esta falla. Se sugiere comparar las dos implementaciones para ver las diferencias. </dd></dl>

<p>Definición en la línea <a class="el" href="oper_8c-source.html#l00070">70</a> del archivo <a class="el" href="oper_8c-source.html">oper.c</a>.</p>

<p>Hace referencia a <a class="el" href="sp__packcol_8h-source.html#l00026">sp_packcol::colp</a>, <a class="el" href="sp__packcol_8h-source.html#l00024">sp_packcol::ncol</a>, <a class="el" href="sp__packcol_8h-source.html#l00023">sp_packcol::nrow</a>, <a class="el" href="sp__packcol_8h-source.html#l00027">sp_packcol::rx</a>, y <a class="el" href="sp__packcol_8h-source.html#l00028">sp_packcol::val</a>.</p>

<p>Referenciado por <a class="el" href="bal_8c-source.html#l00122">bal_mult_vec_packcol_symmetric()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00071"></a>00071 {
<a name="l00072"></a>00072     <span class="keywordtype">int</span> i, ii, j, r;
<a name="l00073"></a>00073 
<a name="l00074"></a>00074     <span class="comment">/* Inicializa vector y */</span>
<a name="l00075"></a>00075     <span class="keywordflow">for</span> (j = 0; j &lt; A-&gt;<a class="code" href="structsp__packcol.html#2e12b2881843b0ff8191f0654570a748" title="Cantidad de filas de la matriz.">nrow</a>; ++j)
<a name="l00076"></a>00076         y[j] = 0;
<a name="l00077"></a>00077 
<a name="l00078"></a>00078     <span class="keywordflow">for</span> (j = 0; j &lt; A-&gt;<a class="code" href="structsp__packcol.html#2cc24559101ca3783f1949c8eebacd7c" title="Cantidad de columnas de la matriz.">ncol</a>; ++j) {
<a name="l00079"></a>00079         i = A-&gt;<a class="code" href="structsp__packcol.html#536659b700c3b21fd5d6cf8538c82b6f" title="Arreglo de indices de fila.">rx</a>[A-&gt;<a class="code" href="structsp__packcol.html#c9a9e31c6b9c1416fff29944568ea18f" title="Arreglo de punteros a los inicios de las columnas.">colp</a>[j]];                      <span class="comment">/* Indice de fila del 1er elem no cero de la columna j */</span>
<a name="l00080"></a>00080 
<a name="l00081"></a>00081         <span class="keywordflow">if</span> (i == j) {                               <span class="comment">/* Si el 1er no cero es la diag */</span>
<a name="l00082"></a>00082             y[j] += ( x[j] * A-&gt;<a class="code" href="structsp__packcol.html#6315b3a8ee78ac66aaae5ba79bda252e" title="Arreglo de valores por debajo de la diagonal.">val</a>[A-&gt;<a class="code" href="structsp__packcol.html#c9a9e31c6b9c1416fff29944568ea18f" title="Arreglo de punteros a los inicios de las columnas.">colp</a>[j]] );  <span class="comment">/* Procesar diagonal: y_j += x_j * A_jj */</span>
<a name="l00083"></a>00083             r = 1;                                  <span class="comment">/* Ignorar la diagonal en el loop interno */</span>
<a name="l00084"></a>00084         }
<a name="l00085"></a>00085         <span class="keywordflow">else</span>
<a name="l00086"></a>00086             r = 0;                                  <span class="comment">/* El 1er elem no cero no es la diagonal. No ignorarlo. */</span>
<a name="l00087"></a>00087 
<a name="l00088"></a>00088         <span class="comment">/* Procesa los elementos no en la diagonal utilizando la propiedad de simetria */</span>
<a name="l00089"></a>00089         <span class="keywordflow">for</span> (ii = A-&gt;<a class="code" href="structsp__packcol.html#c9a9e31c6b9c1416fff29944568ea18f" title="Arreglo de punteros a los inicios de las columnas.">colp</a>[j] + r; ii &lt;= A-&gt;colp[j+1] - 1; ++ii) {
<a name="l00090"></a>00090             i = A-&gt;<a class="code" href="structsp__packcol.html#536659b700c3b21fd5d6cf8538c82b6f" title="Arreglo de indices de fila.">rx</a>[ii];                          <span class="comment">/* Obtiene el indice de fila */</span>
<a name="l00091"></a>00091             y[i] += ( x[j] * A-&gt;<a class="code" href="structsp__packcol.html#6315b3a8ee78ac66aaae5ba79bda252e" title="Arreglo de valores por debajo de la diagonal.">val</a>[ii] );          <span class="comment">/* y_i += x_j * A_ij */</span>
<a name="l00092"></a>00092             y[j] += ( x[i] * A-&gt;<a class="code" href="structsp__packcol.html#6315b3a8ee78ac66aaae5ba79bda252e" title="Arreglo de valores por debajo de la diagonal.">val</a>[ii] );          <span class="comment">/* y_i += x_i * A_ji */</span>
<a name="l00093"></a>00093         }
<a name="l00094"></a>00094     }
<a name="l00095"></a>00095 }
</pre></div>
<p>

</div>
</div><p>
</div>
<hr size="1">
<address style="text-align: right;">
<small>BAL&nbsp;1.0.0<br>Generado el Wed Aug 27 19:54:18 2008.</small>
</address>
</body>
</html>
