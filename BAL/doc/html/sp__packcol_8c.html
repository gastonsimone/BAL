<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>BAL: Referencia del Archivo sparse/sp_packcol.c</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generado por Doxygen 1.5.5 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Página&nbsp;principal</span></a></li>
      <li><a href="pages.html"><span>Páginas&nbsp;relacionadas</span></a></li>
      <li><a href="annotated.html"><span>Estructuras&nbsp;de&nbsp;Datos</span></a></li>
      <li class="current"><a href="files.html"><span>Archivos</span></a></li>
      <li><a href="dirs.html"><span>Directorios</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_3d91f720ca7eb54995d7d6d716b4ce42.html">sparse</a>
  </div>
</div>
<div class="contents">
<h1>Referencia del Archivo sp_packcol.c</h1>Archivo de implementación para formato de matriz dispersa empaquetado por columnas. <a href="#_details">Más...</a>
<p>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &quot;<a class="el" href="sp__packcol_8h-source.html">sp_packcol.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="sp__coord_8h-source.html">sp_coord.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="utils_8h-source.html">../utils.h</a>&quot;</code><br>

<p>
<a href="sp__packcol_8c-source.html">Ir al código fuente de este archivo.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Funciones</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsp__packcol.html">sp_packcol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sp__packcol_8c.html#729d10ec6867249f9b58ceb2683a3318">coord2packcol</a> (<a class="el" href="structsp__coord.html">sp_coord</a> *mat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Genera una instancia de la matriz mat en formato empaquetado por columna.  <a href="#729d10ec6867249f9b58ceb2683a3318"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsp__packcol.html">sp_packcol</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sp__packcol_8c.html#7d8ea564f906cc721e5de1c4a4f5844b">coord2packcol_symmetric</a> (<a class="el" href="structsp__coord.html">sp_coord</a> *mat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Genera una instancia de la matriz mat en formato empaquetado por columna para matrices simétricas.  <a href="#7d8ea564f906cc721e5de1c4a4f5844b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sp__packcol_8c.html#b4d4d490381b43a9628f2001bb6c99d6">sp_imprimir_packcol</a> (FILE *fp, <a class="el" href="structsp__packcol.html">sp_packcol</a> *mat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Imprime la matriz guardada en formato empaquetado por columna en <code>fp</code>.  <a href="#b4d4d490381b43a9628f2001bb6c99d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sp__packcol_8c.html#49b361aae383b0fd323f5735f0ff01bc">row_traversal_packcol</a> (<a class="el" href="structsp__packcol.html">sp_packcol</a> *A, int *i, int *j, int *posij)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementa un mecanismo eficiente para recorrer por filas una matriz dispersa empaquetada por columnas.  <a href="#49b361aae383b0fd323f5735f0ff01bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sp__packcol_8c.html#25a252f919f868ce004aa25b45d44ff3">save_packcol_symmetric</a> (FILE *fp, <a class="el" href="structsp__packcol.html">sp_packcol</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Imprime la matriz simétrica empaquetada por columna en formato matlab en el archivo fp.  <a href="#25a252f919f868ce004aa25b45d44ff3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sp__packcol_8c.html#45eba0df395fde4b428c76d4e688ed62">save_packcol</a> (FILE *fp, <a class="el" href="structsp__packcol.html">sp_packcol</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Imprime la matriz <code>A</code> en formato matlab en el archivo <code>fp</code>.  <a href="#45eba0df395fde4b428c76d4e688ed62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sp__packcol_8c.html#b9f6d408419504b0e7154b221bc0ca4b">free_packcol</a> (<a class="el" href="structsp__packcol.html">sp_packcol</a> *A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Borra toda la memoria reservada por la matriz A.  <a href="#b9f6d408419504b0e7154b221bc0ca4b"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Descripción detallada</h2>
Archivo de implementación para formato de matriz dispersa empaquetado por columnas. 
<p>
Este archivo contiene la implementación de las funciones de utilidad para el formato de matriz dispersa empaquetado por columnas. 
<p>Definición en el archivo <a class="el" href="sp__packcol_8c-source.html">sp_packcol.c</a>.</p>
<hr><h2>Documentación de las funciones</h2>
<a class="anchor" name="729d10ec6867249f9b58ceb2683a3318"></a><!-- doxytag: member="sp_packcol.c::coord2packcol" ref="729d10ec6867249f9b58ceb2683a3318" args="(sp_coord *mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsp__packcol.html">sp_packcol</a> * coord2packcol           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsp__coord.html">sp_coord</a> *&nbsp;</td>
          <td class="paramname"> <em>mat</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Genera una instancia de la matriz mat en formato empaquetado por columna. 
<p>
<dl compact><dt><b>Parámetros:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>Matriz dispersa en formato simple por coordenadas </td></tr>
  </table>
</dl>

<p>Definición en la línea <a class="el" href="sp__packcol_8c-source.html#l00018">18</a> del archivo <a class="el" href="sp__packcol_8c-source.html">sp_packcol.c</a>.</p>

<p>Hace referencia a <a class="el" href="sp__packcol_8h-source.html#l00026">sp_packcol::colp</a>, <a class="el" href="sp__coord_8h-source.html#l00026">sp_coord::cx</a>, <a class="el" href="sp__coord_8h-source.html#l00023">sp_coord::ncol</a>, <a class="el" href="sp__packcol_8h-source.html#l00024">sp_packcol::ncol</a>, <a class="el" href="sp__coord_8h-source.html#l00024">sp_coord::nnz</a>, <a class="el" href="sp__packcol_8h-source.html#l00025">sp_packcol::nnz</a>, <a class="el" href="sp__coord_8h-source.html#l00022">sp_coord::nrow</a>, <a class="el" href="sp__packcol_8h-source.html#l00023">sp_packcol::nrow</a>, <a class="el" href="sp__coord_8h-source.html#l00025">sp_coord::rx</a>, <a class="el" href="sp__packcol_8h-source.html#l00027">sp_packcol::rx</a>, <a class="el" href="sp__coord_8h-source.html#l00027">sp_coord::val</a>, y <a class="el" href="sp__packcol_8h-source.html#l00028">sp_packcol::val</a>.</p>

<p>Referenciado por <a class="el" href="bal_8c-source.html#l00082">bal_coord2packcol()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00019"></a>00019 {
<a name="l00020"></a>00020     <span class="keywordtype">int</span> i, j, col;
<a name="l00021"></a>00021     <a class="code" href="structsp__packcol.html" title="Estructura de matriz dispersa empaquetada por columna.">sp_packcol</a>* packcol = (<a class="code" href="structsp__packcol.html" title="Estructura de matriz dispersa empaquetada por columna.">sp_packcol</a>*)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structsp__packcol.html" title="Estructura de matriz dispersa empaquetada por columna.">sp_packcol</a>));
<a name="l00022"></a>00022 
<a name="l00023"></a>00023     packcol-&gt;<a class="code" href="structsp__packcol.html#2e12b2881843b0ff8191f0654570a748" title="Cantidad de filas de la matriz.">nrow</a> = mat-&gt;<a class="code" href="structsp__coord.html#adf22f93c8e3ce7303018ba9a01ea092" title="Cantidad de filas.">nrow</a>;
<a name="l00024"></a>00024     packcol-&gt;<a class="code" href="structsp__packcol.html#2cc24559101ca3783f1949c8eebacd7c" title="Cantidad de columnas de la matriz.">ncol</a> = mat-&gt;<a class="code" href="structsp__coord.html#b962ad3a8f62df6906409d1392611c63" title="Cantidad de columnas.">ncol</a>;
<a name="l00025"></a>00025     packcol-&gt;<a class="code" href="structsp__packcol.html#667202fa30dd3d49982e3b0c8148bde4" title="Cantidad de elementos no cero.">nnz</a> = mat-&gt;<a class="code" href="structsp__coord.html#f36cd76459da9943ba491ee4a3b1f467" title="Cantidad de elementos no cero.">nnz</a>;
<a name="l00026"></a>00026 
<a name="l00027"></a>00027     <span class="keywordflow">if</span> (packcol-&gt;<a class="code" href="structsp__packcol.html#667202fa30dd3d49982e3b0c8148bde4" title="Cantidad de elementos no cero.">nnz</a> == 0) {
<a name="l00028"></a>00028         packcol-&gt;<a class="code" href="structsp__packcol.html#c9a9e31c6b9c1416fff29944568ea18f" title="Arreglo de punteros a los inicios de las columnas.">colp</a> = NULL;
<a name="l00029"></a>00029         packcol-&gt;<a class="code" href="structsp__packcol.html#536659b700c3b21fd5d6cf8538c82b6f" title="Arreglo de indices de fila.">rx</a> = NULL;
<a name="l00030"></a>00030         packcol-&gt;<a class="code" href="structsp__packcol.html#6315b3a8ee78ac66aaae5ba79bda252e" title="Arreglo de valores por debajo de la diagonal.">val</a> = NULL;
<a name="l00031"></a>00031     }
<a name="l00032"></a>00032     <span class="keywordflow">else</span> {
<a name="l00033"></a>00033         packcol-&gt;<a class="code" href="structsp__packcol.html#c9a9e31c6b9c1416fff29944568ea18f" title="Arreglo de punteros a los inicios de las columnas.">colp</a> = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) * (packcol-&gt;<a class="code" href="structsp__packcol.html#2cc24559101ca3783f1949c8eebacd7c" title="Cantidad de columnas de la matriz.">ncol</a>+1));
<a name="l00034"></a>00034         packcol-&gt;<a class="code" href="structsp__packcol.html#536659b700c3b21fd5d6cf8538c82b6f" title="Arreglo de indices de fila.">rx</a> = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) * packcol-&gt;<a class="code" href="structsp__packcol.html#667202fa30dd3d49982e3b0c8148bde4" title="Cantidad de elementos no cero.">nnz</a>);
<a name="l00035"></a>00035         packcol-&gt;<a class="code" href="structsp__packcol.html#6315b3a8ee78ac66aaae5ba79bda252e" title="Arreglo de valores por debajo de la diagonal.">val</a> = (<span class="keywordtype">double</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * packcol-&gt;<a class="code" href="structsp__packcol.html#667202fa30dd3d49982e3b0c8148bde4" title="Cantidad de elementos no cero.">nnz</a>);
<a name="l00036"></a>00036 
<a name="l00037"></a>00037         j = 0;
<a name="l00038"></a>00038         <span class="keywordflow">for</span>(col=0; col &lt; packcol-&gt;<a class="code" href="structsp__packcol.html#2cc24559101ca3783f1949c8eebacd7c" title="Cantidad de columnas de la matriz.">ncol</a>; ++col) {    <span class="comment">/*&lt; Para cada columna col */</span>
<a name="l00039"></a>00039             packcol-&gt;<a class="code" href="structsp__packcol.html#c9a9e31c6b9c1416fff29944568ea18f" title="Arreglo de punteros a los inicios de las columnas.">colp</a>[col] = j;                 <span class="comment">/*&lt; El 1er elem de la columna col esta en la posicion j de val */</span>
<a name="l00040"></a>00040             <span class="keywordflow">for</span>(i=0; i &lt; mat-&gt;<a class="code" href="structsp__coord.html#f36cd76459da9943ba491ee4a3b1f467" title="Cantidad de elementos no cero.">nnz</a>; ++i) {           <span class="comment">/*&lt; Recorro los elementos no-cero de mat */</span>
<a name="l00041"></a>00041                 <span class="keywordflow">if</span> (mat-&gt;<a class="code" href="structsp__coord.html#cdb4f5d3b6a4a24dfaf7aa94894d3c52" title="Arreglo de indices de columna.">cx</a>[i] == col) {            <span class="comment">/*&lt; Si es un elemento de la columna col */</span>
<a name="l00042"></a>00042                     packcol-&gt;<a class="code" href="structsp__packcol.html#6315b3a8ee78ac66aaae5ba79bda252e" title="Arreglo de valores por debajo de la diagonal.">val</a>[j] = mat-&gt;<a class="code" href="structsp__coord.html#bf936aab79fa2aefba9c7d42e2ee401c" title="Arreglos de valores.">val</a>[i];  <span class="comment">/*&lt; Guardo el valor */</span>
<a name="l00043"></a>00043                     packcol-&gt;<a class="code" href="structsp__packcol.html#536659b700c3b21fd5d6cf8538c82b6f" title="Arreglo de indices de fila.">rx</a>[j] = mat-&gt;<a class="code" href="structsp__coord.html#a50e5d65cdb79f9a0f2b7d7505ce7c67" title="Arreglo de indices de fila.">rx</a>[i];    <span class="comment">/*&lt; Guardo el numero de fila */</span>
<a name="l00044"></a>00044                     ++j;
<a name="l00045"></a>00045                 }
<a name="l00046"></a>00046             }
<a name="l00047"></a>00047         }
<a name="l00048"></a>00048         packcol-&gt;<a class="code" href="structsp__packcol.html#c9a9e31c6b9c1416fff29944568ea18f" title="Arreglo de punteros a los inicios de las columnas.">colp</a>[col] = j;                 <span class="comment">/*&lt; Elemento extra para indicar el fin de la ultima columna */</span>
<a name="l00049"></a>00049     }
<a name="l00050"></a>00050 
<a name="l00051"></a>00051     <span class="keywordflow">return</span> packcol;
<a name="l00052"></a>00052 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="7d8ea564f906cc721e5de1c4a4f5844b"></a><!-- doxytag: member="sp_packcol.c::coord2packcol_symmetric" ref="7d8ea564f906cc721e5de1c4a4f5844b" args="(sp_coord *mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsp__packcol.html">sp_packcol</a> * coord2packcol_symmetric           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsp__coord.html">sp_coord</a> *&nbsp;</td>
          <td class="paramname"> <em>mat</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Genera una instancia de la matriz mat en formato empaquetado por columna para matrices simétricas. 
<p>
<dl compact><dt><b>Parámetros:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>Matriz dispersa en formato simple por coordenadas</td></tr>
  </table>
</dl>
En el caso de que mat sea una matriz simétrica, no es necesario guardar todos los elementos no cero. Basta con guardar los elementos no cero de una de las triangulares.<p>
Esta función genera una representación de la matriz mat en formato empaquetado por columna, guardando en ella solo los elementos que están en la diagonal mayor y por debajo de ella, economizando memoria y sin perder información.<p>
Por supuesto, esta función debe ser utilizada solo cuando mat es simétrica y se desea tener la ganancia de memoria. Las rutinas que utilicen la estructura generada por esta función deberán tener en cuenta sus características para realizar las tareas de forma correcta. 
<p>Definición en la línea <a class="el" href="sp__packcol_8c-source.html#l00069">69</a> del archivo <a class="el" href="sp__packcol_8c-source.html">sp_packcol.c</a>.</p>

<p>Hace referencia a <a class="el" href="utils_8h-source.html#l00016">BAL_ERROR</a>, <a class="el" href="sp__packcol_8h-source.html#l00026">sp_packcol::colp</a>, <a class="el" href="sp__coord_8h-source.html#l00026">sp_coord::cx</a>, <a class="el" href="sp__packcol_8h-source.html#l00024">sp_packcol::ncol</a>, <a class="el" href="sp__coord_8h-source.html#l00023">sp_coord::ncol</a>, <a class="el" href="sp__packcol_8h-source.html#l00025">sp_packcol::nnz</a>, <a class="el" href="sp__coord_8h-source.html#l00024">sp_coord::nnz</a>, <a class="el" href="sp__packcol_8h-source.html#l00023">sp_packcol::nrow</a>, <a class="el" href="sp__coord_8h-source.html#l00022">sp_coord::nrow</a>, <a class="el" href="sp__coord_8h-source.html#l00025">sp_coord::rx</a>, <a class="el" href="sp__packcol_8h-source.html#l00027">sp_packcol::rx</a>, <a class="el" href="sp__coord_8h-source.html#l00027">sp_coord::val</a>, y <a class="el" href="sp__packcol_8h-source.html#l00028">sp_packcol::val</a>.</p>

<p>Referenciado por <a class="el" href="bal_8c-source.html#l00092">bal_coord2packcol_symmetric()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00070"></a>00070 {
<a name="l00071"></a>00071     <span class="keywordtype">int</span> i, j, col, nnz;
<a name="l00072"></a>00072     <a class="code" href="structsp__packcol.html" title="Estructura de matriz dispersa empaquetada por columna.">sp_packcol</a>* packcol = (<a class="code" href="structsp__packcol.html" title="Estructura de matriz dispersa empaquetada por columna.">sp_packcol</a>*)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structsp__packcol.html" title="Estructura de matriz dispersa empaquetada por columna.">sp_packcol</a>));
<a name="l00073"></a>00073 
<a name="l00074"></a>00074     <span class="keywordflow">if</span> (mat-&gt;<a class="code" href="structsp__coord.html#adf22f93c8e3ce7303018ba9a01ea092" title="Cantidad de filas.">nrow</a> != mat-&gt;<a class="code" href="structsp__coord.html#b962ad3a8f62df6906409d1392611c63" title="Cantidad de columnas.">ncol</a>) {
<a name="l00075"></a>00075         <a class="code" href="utils_8h.html#f9a64ef5874a8560a9067ac3191cced4" title="Función para reportar errores detectados por código de BAL.">BAL_ERROR</a>(<span class="stringliteral">"La matriz debe ser cuadrada para poder ser simetrica."</span>);
<a name="l00076"></a>00076         <span class="keywordflow">return</span> NULL;
<a name="l00077"></a>00077     }
<a name="l00078"></a>00078 
<a name="l00079"></a>00079     packcol-&gt;<a class="code" href="structsp__packcol.html#2e12b2881843b0ff8191f0654570a748" title="Cantidad de filas de la matriz.">nrow</a> = mat-&gt;<a class="code" href="structsp__coord.html#adf22f93c8e3ce7303018ba9a01ea092" title="Cantidad de filas.">nrow</a>;
<a name="l00080"></a>00080     packcol-&gt;<a class="code" href="structsp__packcol.html#2cc24559101ca3783f1949c8eebacd7c" title="Cantidad de columnas de la matriz.">ncol</a> = mat-&gt;<a class="code" href="structsp__coord.html#b962ad3a8f62df6906409d1392611c63" title="Cantidad de columnas.">ncol</a>;
<a name="l00081"></a>00081 
<a name="l00082"></a>00082     <span class="keywordflow">if</span> (mat-&gt;<a class="code" href="structsp__coord.html#f36cd76459da9943ba491ee4a3b1f467" title="Cantidad de elementos no cero.">nnz</a> == 0) {
<a name="l00083"></a>00083         packcol-&gt;<a class="code" href="structsp__packcol.html#c9a9e31c6b9c1416fff29944568ea18f" title="Arreglo de punteros a los inicios de las columnas.">colp</a> = NULL;
<a name="l00084"></a>00084         packcol-&gt;<a class="code" href="structsp__packcol.html#536659b700c3b21fd5d6cf8538c82b6f" title="Arreglo de indices de fila.">rx</a> = NULL;
<a name="l00085"></a>00085         packcol-&gt;<a class="code" href="structsp__packcol.html#6315b3a8ee78ac66aaae5ba79bda252e" title="Arreglo de valores por debajo de la diagonal.">val</a> = NULL;
<a name="l00086"></a>00086     }
<a name="l00087"></a>00087     <span class="keywordflow">else</span> {
<a name="l00088"></a>00088         <span class="comment">/* Calcula la cantidad de elementos no cero debajo y en la diagonal */</span>
<a name="l00089"></a>00089         nnz = 0;
<a name="l00090"></a>00090         <span class="keywordflow">for</span>(i=0; i &lt; mat-&gt;<a class="code" href="structsp__coord.html#f36cd76459da9943ba491ee4a3b1f467" title="Cantidad de elementos no cero.">nnz</a>; ++i) {
<a name="l00091"></a>00091             <span class="keywordflow">if</span> (mat-&gt;<a class="code" href="structsp__coord.html#a50e5d65cdb79f9a0f2b7d7505ce7c67" title="Arreglo de indices de fila.">rx</a>[i] &gt;= mat-&gt;<a class="code" href="structsp__coord.html#cdb4f5d3b6a4a24dfaf7aa94894d3c52" title="Arreglo de indices de columna.">cx</a>[i])
<a name="l00092"></a>00092                 ++nnz;
<a name="l00093"></a>00093         }
<a name="l00094"></a>00094 
<a name="l00095"></a>00095         packcol-&gt;<a class="code" href="structsp__packcol.html#667202fa30dd3d49982e3b0c8148bde4" title="Cantidad de elementos no cero.">nnz</a> = nnz;
<a name="l00096"></a>00096         packcol-&gt;<a class="code" href="structsp__packcol.html#c9a9e31c6b9c1416fff29944568ea18f" title="Arreglo de punteros a los inicios de las columnas.">colp</a> = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) * (packcol-&gt;<a class="code" href="structsp__packcol.html#2cc24559101ca3783f1949c8eebacd7c" title="Cantidad de columnas de la matriz.">ncol</a>+1));
<a name="l00097"></a>00097         packcol-&gt;<a class="code" href="structsp__packcol.html#536659b700c3b21fd5d6cf8538c82b6f" title="Arreglo de indices de fila.">rx</a> = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) * nnz);
<a name="l00098"></a>00098         packcol-&gt;<a class="code" href="structsp__packcol.html#6315b3a8ee78ac66aaae5ba79bda252e" title="Arreglo de valores por debajo de la diagonal.">val</a> = (<span class="keywordtype">double</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * nnz);
<a name="l00099"></a>00099 
<a name="l00100"></a>00100         j = 0;
<a name="l00101"></a>00101         <span class="keywordflow">for</span>(col=0; col &lt; packcol-&gt;<a class="code" href="structsp__packcol.html#2cc24559101ca3783f1949c8eebacd7c" title="Cantidad de columnas de la matriz.">ncol</a>; ++col) {                        <span class="comment">/*&lt; Para cada columna col */</span>
<a name="l00102"></a>00102             packcol-&gt;<a class="code" href="structsp__packcol.html#c9a9e31c6b9c1416fff29944568ea18f" title="Arreglo de punteros a los inicios de las columnas.">colp</a>[col] = j;                                     <span class="comment">/*&lt; El 1er elem de la columna col esta en la posicion j de val */</span>
<a name="l00103"></a>00103             <span class="keywordflow">for</span>(i=0; i &lt; mat-&gt;<a class="code" href="structsp__coord.html#f36cd76459da9943ba491ee4a3b1f467" title="Cantidad de elementos no cero.">nnz</a>; ++i) {                               <span class="comment">/*&lt; Recorro los elementos no-cero de mat */</span>
<a name="l00104"></a>00104                 <span class="keywordflow">if</span> (mat-&gt;<a class="code" href="structsp__coord.html#a50e5d65cdb79f9a0f2b7d7505ce7c67" title="Arreglo de indices de fila.">rx</a>[i] &gt;= mat-&gt;<a class="code" href="structsp__coord.html#cdb4f5d3b6a4a24dfaf7aa94894d3c52" title="Arreglo de indices de columna.">cx</a>[i] &amp;&amp; mat-&gt;<a class="code" href="structsp__coord.html#cdb4f5d3b6a4a24dfaf7aa94894d3c52" title="Arreglo de indices de columna.">cx</a>[i] == col) {    <span class="comment">/*&lt; Si es un elemento de la columna col */</span>
<a name="l00105"></a>00105                     packcol-&gt;<a class="code" href="structsp__packcol.html#6315b3a8ee78ac66aaae5ba79bda252e" title="Arreglo de valores por debajo de la diagonal.">val</a>[j] = mat-&gt;<a class="code" href="structsp__coord.html#bf936aab79fa2aefba9c7d42e2ee401c" title="Arreglos de valores.">val</a>[i];                      <span class="comment">/*&lt; Guardo el valor */</span>
<a name="l00106"></a>00106                     packcol-&gt;<a class="code" href="structsp__packcol.html#536659b700c3b21fd5d6cf8538c82b6f" title="Arreglo de indices de fila.">rx</a>[j] = mat-&gt;<a class="code" href="structsp__coord.html#a50e5d65cdb79f9a0f2b7d7505ce7c67" title="Arreglo de indices de fila.">rx</a>[i];                        <span class="comment">/*&lt; Guardo el numero de fila */</span>
<a name="l00107"></a>00107                     ++j;
<a name="l00108"></a>00108                 }
<a name="l00109"></a>00109             }
<a name="l00110"></a>00110         }
<a name="l00111"></a>00111         packcol-&gt;<a class="code" href="structsp__packcol.html#c9a9e31c6b9c1416fff29944568ea18f" title="Arreglo de punteros a los inicios de las columnas.">colp</a>[col] = j;                 <span class="comment">/*&lt; Elemento extra para indicar el fin de la ultima columna */</span>
<a name="l00112"></a>00112     }
<a name="l00113"></a>00113 
<a name="l00114"></a>00114     <span class="keywordflow">return</span> packcol;
<a name="l00115"></a>00115 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b9f6d408419504b0e7154b221bc0ca4b"></a><!-- doxytag: member="sp_packcol.c::free_packcol" ref="b9f6d408419504b0e7154b221bc0ca4b" args="(sp_packcol *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_packcol           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsp__packcol.html">sp_packcol</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Borra toda la memoria reservada por la matriz A. 
<p>
Esta función libera toda la memoria reservada por las estructura de datos <a class="el" href="structsp__packcol.html" title="Estructura de matriz dispersa empaquetada por columna.">sp_packcol</a>. 
<p>Definición en la línea <a class="el" href="sp__packcol_8c-source.html#l00348">348</a> del archivo <a class="el" href="sp__packcol_8c-source.html">sp_packcol.c</a>.</p>

<p>Hace referencia a <a class="el" href="sp__packcol_8h-source.html#l00026">sp_packcol::colp</a>, <a class="el" href="sp__packcol_8h-source.html#l00027">sp_packcol::rx</a>, y <a class="el" href="sp__packcol_8h-source.html#l00028">sp_packcol::val</a>.</p>

<p>Referenciado por <a class="el" href="bal_8c-source.html#l00322">bal_free_packcol()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00349"></a>00349 {
<a name="l00350"></a>00350     free(A-&gt;<a class="code" href="structsp__packcol.html#c9a9e31c6b9c1416fff29944568ea18f" title="Arreglo de punteros a los inicios de las columnas.">colp</a>);
<a name="l00351"></a>00351     free(A-&gt;<a class="code" href="structsp__packcol.html#536659b700c3b21fd5d6cf8538c82b6f" title="Arreglo de indices de fila.">rx</a>);
<a name="l00352"></a>00352     free(A-&gt;<a class="code" href="structsp__packcol.html#6315b3a8ee78ac66aaae5ba79bda252e" title="Arreglo de valores por debajo de la diagonal.">val</a>);
<a name="l00353"></a>00353     free(A);
<a name="l00354"></a>00354 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="49b361aae383b0fd323f5735f0ff01bc"></a><!-- doxytag: member="sp_packcol.c::row_traversal_packcol" ref="49b361aae383b0fd323f5735f0ff01bc" args="(sp_packcol *A, int *i, int *j, int *posij)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int row_traversal_packcol           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsp__packcol.html">sp_packcol</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>posij</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Implementa un mecanismo eficiente para recorrer por filas una matriz dispersa empaquetada por columnas. 
<p>
<dl compact><dt><b>Parámetros:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>ENTRADA: Matriz a recorrer por filas en formato empaquetado por columna con mejora por simetría. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>ENTRADA/SALIDA: Si <code>i = -2</code>, la rutina es inicializada. En otro caso, <code>i</code> guarda el índice de la fila leída. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>j</em>&nbsp;</td><td>SALIDA: Guarda el índice de la columna leída. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>posij</em>&nbsp;</td><td>SALIDA: Indica la posición de <code>A[i.j]</code> en <code>A-&gt;val</code>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Devuelve:</b></dt><dd>-1 si se llegó al final de una línea, <code>j</code> en caso contrario.</dd></dl>
Dada la forma de guardar los datos en memoria de la estructura <a class="el" href="structsp__packcol.html" title="Estructura de matriz dispersa empaquetada por columna.">sp_packcol</a>, no es trivial recorrer la matriz por filas de forma eficiente. Esta función implementa un mecanismo para ir obteniendo los valores de una <a class="el" href="structsp__packcol.html" title="Estructura de matriz dispersa empaquetada por columna.">sp_packcol</a> por fila.<p>
<dl class="warning" compact><dt><b>Atención:</b></dt><dd>Esté método solo es útil para matrices simétricas guardadas tal como lo hace <a class="el" href="sp__packcol_8c.html#7d8ea564f906cc721e5de1c4a4f5844b" title="Genera una instancia de la matriz mat en formato empaquetado por columna para matrices...">coord2packcol_symmetric()</a>.<p>
No se debe cambiar el valor de las variables <code>i</code> y <code>j</code> mientras se está recorriendo una matriz utilizando esta función.<p>
Esta función devuelve todos los elementos de una fila <code>i</code> antes de devolver los elementos de la fila <code>i+1</code>, pero los elementos de una misma fila no son devueltos en ningún orden en particular (por ejemplo, ordenados por columna, que sería lo más natural). Más precisamente, la rutina siempre devuelve primero el elemento de la diagonal mayor <code>(i,i)</code>, (en caso que no sea cero), pero el resto de los elementos no tienen un orden particular definido.</dd></dl>
<dl class="note" compact><dt><b>Nota:</b></dt><dd>Este algoritmo brinda un método de recorrido por fila que presenta un tiempo de ejecución de <em>O(A.nnz)</em> y conlleva un costo extra en memoria de <em>2n</em> variables de tipo entero, siendo <code>n</code> la cantidad de filas y columnas de <code>A</code>.<p>
Esta función está basada en la descripción de la sección 5.3 del paper de Stewart (Ver las <a class="el" href="index.html#refsec">referencias</a>). Puede ver ese documento o el juego de rutinas de prueba de BAL por un ejemplo de cómo utilizar esta rutina.<p>
Esta rutina utiliza memoria dinámica para trabajar. Puede llamar a esta función con <code>A = NULL</code> y <code>i = -2</code> para liberar la memoria utilizada. Note que esto es diferente a llamar la rutina para que se inicialice, en la que la misma reserva memoria para trabajar. </dd></dl>

<p>Definición en la línea <a class="el" href="sp__packcol_8c-source.html#l00203">203</a> del archivo <a class="el" href="sp__packcol_8c-source.html">sp_packcol.c</a>.</p>

<p>Hace referencia a <a class="el" href="sp__packcol_8h-source.html#l00026">sp_packcol::colp</a>, <a class="el" href="sp__packcol_8h-source.html#l00024">sp_packcol::ncol</a>, y <a class="el" href="sp__packcol_8h-source.html#l00027">sp_packcol::rx</a>.</p>

<p>Referenciado por <a class="el" href="bal_8c-source.html#l00142">bal_row_traversal_packcol()</a>, <a class="el" href="cholesky_8c-source.html#l00042">elimination_tree()</a>, <a class="el" href="cholesky_8c-source.html#l00274">numerical_factorization()</a>, y <a class="el" href="sp__packcol_8c-source.html#l00275">save_packcol_symmetric()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00204"></a>00204 {
<a name="l00205"></a>00205     <span class="keyword">static</span> <span class="keywordtype">int</span> *link = NULL;
<a name="l00206"></a>00206     <span class="keyword">static</span> <span class="keywordtype">int</span> *pos = NULL;
<a name="l00207"></a>00207     <span class="keyword">static</span> <span class="keywordtype">int</span> nextj = -1;
<a name="l00208"></a>00208     <span class="keywordtype">int</span> x, nextdown, id;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210     <span class="keywordflow">if</span> (*i == -2) { <span class="comment">/* Inicializacion */</span>
<a name="l00211"></a>00211         <span class="keywordflow">if</span> (link != NULL)
<a name="l00212"></a>00212             free(link);
<a name="l00213"></a>00213 
<a name="l00214"></a>00214         <span class="keywordflow">if</span> (pos != NULL)
<a name="l00215"></a>00215             free(pos);
<a name="l00216"></a>00216 
<a name="l00217"></a>00217         <span class="keywordflow">if</span> (A == NULL) {
<a name="l00218"></a>00218             link = pos = NULL;
<a name="l00219"></a>00219             <span class="keywordflow">return</span> -1;
<a name="l00220"></a>00220         }
<a name="l00221"></a>00221 
<a name="l00222"></a>00222         link = (<span class="keywordtype">int</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * A-&gt;<a class="code" href="structsp__packcol.html#2cc24559101ca3783f1949c8eebacd7c" title="Cantidad de columnas de la matriz.">ncol</a>);
<a name="l00223"></a>00223         pos = (<span class="keywordtype">int</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * A-&gt;<a class="code" href="structsp__packcol.html#2cc24559101ca3783f1949c8eebacd7c" title="Cantidad de columnas de la matriz.">ncol</a>);
<a name="l00224"></a>00224         <span class="keywordflow">for</span> (x = 0; x &lt; A-&gt;<a class="code" href="structsp__packcol.html#2cc24559101ca3783f1949c8eebacd7c" title="Cantidad de columnas de la matriz.">ncol</a>; ++x)
<a name="l00225"></a>00225             link[x] = pos[x] = -1;
<a name="l00226"></a>00226 
<a name="l00227"></a>00227         *i = *j = -1;
<a name="l00228"></a>00228         <span class="keywordflow">return</span> -1;
<a name="l00229"></a>00229     }
<a name="l00230"></a>00230 
<a name="l00231"></a>00231     <span class="keywordflow">if</span> (*j == -1) { <span class="comment">/* Preparamos la fila i */</span>
<a name="l00232"></a>00232         *i += 1;
<a name="l00233"></a>00233         *j = *i;
<a name="l00234"></a>00234         *posij = A-&gt;<a class="code" href="structsp__packcol.html#c9a9e31c6b9c1416fff29944568ea18f" title="Arreglo de punteros a los inicios de las columnas.">colp</a>[*i];
<a name="l00235"></a>00235     }
<a name="l00236"></a>00236     <span class="keywordflow">else</span> { <span class="comment">/* Obtener el siguiente elemento de la fila i */</span>
<a name="l00237"></a>00237         *j = nextj;
<a name="l00238"></a>00238 
<a name="l00239"></a>00239         <span class="keywordflow">if</span> (*j == -1)
<a name="l00240"></a>00240             <span class="keywordflow">return</span> *j;  <span class="comment">/* Fin de fila */</span>
<a name="l00241"></a>00241 
<a name="l00242"></a>00242         *posij = pos[*j];
<a name="l00243"></a>00243     }
<a name="l00244"></a>00244 
<a name="l00245"></a>00245     nextj = link[*j];
<a name="l00246"></a>00246     link[*j] = -1;
<a name="l00247"></a>00247     nextdown = *posij + 1;
<a name="l00248"></a>00248 
<a name="l00249"></a>00249     <span class="keywordflow">if</span> (nextdown &lt; A-&gt;colp[*j + 1]) {   <span class="comment">/* Hay un elemento en la columna j, recordarlo */</span>
<a name="l00250"></a>00250         pos[*j] = nextdown;
<a name="l00251"></a>00251         <span class="keywordtype">id</span> = A-&gt;<a class="code" href="structsp__packcol.html#536659b700c3b21fd5d6cf8538c82b6f" title="Arreglo de indices de fila.">rx</a>[nextdown];
<a name="l00252"></a>00252         link[*j] = link[id];
<a name="l00253"></a>00253         link[id] = *j;
<a name="l00254"></a>00254     }
<a name="l00255"></a>00255 
<a name="l00256"></a>00256     <span class="keywordflow">return</span> *j;
<a name="l00257"></a>00257 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="45eba0df395fde4b428c76d4e688ed62"></a><!-- doxytag: member="sp_packcol.c::save_packcol" ref="45eba0df395fde4b428c76d4e688ed62" args="(FILE *fp, sp_packcol *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void save_packcol           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsp__packcol.html">sp_packcol</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Imprime la matriz <code>A</code> en formato matlab en el archivo <code>fp</code>. 
<p>
<dl compact><dt><b>Parámetros:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>Puntero a archivo donde imprimir la matriz A. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>Matriz simétrica empaquetada por columna a imprimir en formato matlab.</td></tr>
  </table>
</dl>
Esta función es útil para respaldar matrices. 
<p>Definición en la línea <a class="el" href="sp__packcol_8c-source.html#l00316">316</a> del archivo <a class="el" href="sp__packcol_8c-source.html">sp_packcol.c</a>.</p>

<p>Hace referencia a <a class="el" href="sp__packcol_8h-source.html#l00026">sp_packcol::colp</a>, <a class="el" href="sp__packcol_8h-source.html#l00024">sp_packcol::ncol</a>, <a class="el" href="sp__packcol_8h-source.html#l00023">sp_packcol::nrow</a>, <a class="el" href="sp__packcol_8h-source.html#l00027">sp_packcol::rx</a>, y <a class="el" href="sp__packcol_8h-source.html#l00028">sp_packcol::val</a>.</p>

<p>Referenciado por <a class="el" href="bal_8c-source.html#l00182">bal_save_packcol()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00317"></a>00317 {
<a name="l00318"></a>00318     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, j, k, encontrado;
<a name="l00319"></a>00319 
<a name="l00320"></a>00320     fprintf(fp, <span class="stringliteral">"[\n"</span>);
<a name="l00321"></a>00321     <span class="keywordflow">for</span> (i=0; i &lt; A-&gt;<a class="code" href="structsp__packcol.html#2e12b2881843b0ff8191f0654570a748" title="Cantidad de filas de la matriz.">nrow</a>; ++i) {           <span class="comment">/* Por cada fila */</span>
<a name="l00322"></a>00322         <span class="keywordflow">for</span> (j=0; j &lt; A-&gt;<a class="code" href="structsp__packcol.html#2cc24559101ca3783f1949c8eebacd7c" title="Cantidad de columnas de la matriz.">ncol</a>; ++j) {       <span class="comment">/* Por cada columna */</span>
<a name="l00323"></a>00323             <span class="comment">/* Busca la entrada (i,j) en la columna j de A */</span>
<a name="l00324"></a>00324             encontrado = 0;
<a name="l00325"></a>00325             <span class="keywordflow">for</span> (k=A-&gt;<a class="code" href="structsp__packcol.html#c9a9e31c6b9c1416fff29944568ea18f" title="Arreglo de punteros a los inicios de las columnas.">colp</a>[j]; k &lt; A-&gt;colp[j+1]; ++k) {
<a name="l00326"></a>00326                 <span class="keywordflow">if</span> (A-&gt;<a class="code" href="structsp__packcol.html#536659b700c3b21fd5d6cf8538c82b6f" title="Arreglo de indices de fila.">rx</a>[k] == i) {
<a name="l00327"></a>00327                     encontrado = 1;
<a name="l00328"></a>00328                     fprintf(fp, <span class="stringliteral">" %g"</span>, A-&gt;<a class="code" href="structsp__packcol.html#6315b3a8ee78ac66aaae5ba79bda252e" title="Arreglo de valores por debajo de la diagonal.">val</a>[k]);
<a name="l00329"></a>00329                     <span class="keywordflow">break</span>;
<a name="l00330"></a>00330                 }
<a name="l00331"></a>00331             }
<a name="l00332"></a>00332             <span class="keywordflow">if</span> (!encontrado)
<a name="l00333"></a>00333                 fprintf(fp, <span class="stringliteral">" 0"</span>);
<a name="l00334"></a>00334         }
<a name="l00335"></a>00335         <span class="keywordflow">if</span> (i+1 &lt; A-&gt;<a class="code" href="structsp__packcol.html#2e12b2881843b0ff8191f0654570a748" title="Cantidad de filas de la matriz.">nrow</a>)
<a name="l00336"></a>00336             fprintf(fp, <span class="stringliteral">";\n"</span>);
<a name="l00337"></a>00337         <span class="keywordflow">else</span>
<a name="l00338"></a>00338             fprintf(fp, <span class="stringliteral">"\n"</span>);
<a name="l00339"></a>00339     }
<a name="l00340"></a>00340     fprintf(fp, <span class="stringliteral">"]\n"</span>);
<a name="l00341"></a>00341 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="25a252f919f868ce004aa25b45d44ff3"></a><!-- doxytag: member="sp_packcol.c::save_packcol_symmetric" ref="25a252f919f868ce004aa25b45d44ff3" args="(FILE *fp, sp_packcol *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void save_packcol_symmetric           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsp__packcol.html">sp_packcol</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Imprime la matriz simétrica empaquetada por columna en formato matlab en el archivo fp. 
<p>
<dl compact><dt><b>Parámetros:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>Puntero a archivo donde imprimir la matriz A. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>Matriz simétrica empaquetada por columna a imprimir en formato matlab.</td></tr>
  </table>
</dl>
Esta función es útil para respaldar matrices.<p>
<dl class="note" compact><dt><b>Nota:</b></dt><dd>Esta función solo funciona para matrices empaquetadas por columna que fueron guardadas con la mejora para matrices simétricas, tal como lo hace la función coord2packcol_symmetric.</dd></dl>
<dl class="warning" compact><dt><b>Atención:</b></dt><dd>La salida produce solo la triangular inferior de la matriz, para una salida completa, utilice <a class="el" href="sp__packcol_8c.html#45eba0df395fde4b428c76d4e688ed62" title="Imprime la matriz A en formato matlab en el archivo fp.">save_packcol()</a>. </dd></dl>

<p>Definición en la línea <a class="el" href="sp__packcol_8c-source.html#l00275">275</a> del archivo <a class="el" href="sp__packcol_8c-source.html">sp_packcol.c</a>.</p>

<p>Hace referencia a <a class="el" href="sp__packcol_8h-source.html#l00024">sp_packcol::ncol</a>, <a class="el" href="sp__packcol_8h-source.html#l00023">sp_packcol::nrow</a>, <a class="el" href="sp__packcol_8c-source.html#l00203">row_traversal_packcol()</a>, y <a class="el" href="sp__packcol_8h-source.html#l00028">sp_packcol::val</a>.</p>

<p>Referenciado por <a class="el" href="bal_8c-source.html#l00172">bal_save_packcol_symmetric()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00276"></a>00276 {
<a name="l00277"></a>00277     <span class="keywordtype">int</span> x, y, i, j, posij;
<a name="l00278"></a>00278     <span class="keywordtype">double</span> *fila;
<a name="l00279"></a>00279 
<a name="l00280"></a>00280     fila = (<span class="keywordtype">double</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * A-&gt;<a class="code" href="structsp__packcol.html#2cc24559101ca3783f1949c8eebacd7c" title="Cantidad de columnas de la matriz.">ncol</a>);
<a name="l00281"></a>00281 
<a name="l00282"></a>00282     fprintf(fp, <span class="stringliteral">"[\n"</span>);
<a name="l00283"></a>00283 
<a name="l00284"></a>00284     i = -2;
<a name="l00285"></a>00285     <a class="code" href="sp__packcol_8c.html#49b361aae383b0fd323f5735f0ff01bc" title="Implementa un mecanismo eficiente para recorrer por filas una matriz dispersa empaquetada...">row_traversal_packcol</a>(A, &amp;i, &amp;j, &amp;posij);
<a name="l00286"></a>00286     <span class="keywordflow">for</span> (x = 0; x &lt; A-&gt;<a class="code" href="structsp__packcol.html#2e12b2881843b0ff8191f0654570a748" title="Cantidad de filas de la matriz.">nrow</a>; ++x) { <span class="comment">/* Por cada fila */</span>
<a name="l00287"></a>00287 
<a name="l00288"></a>00288         <span class="keywordflow">for</span> (y=0; y &lt; A-&gt;<a class="code" href="structsp__packcol.html#2cc24559101ca3783f1949c8eebacd7c" title="Cantidad de columnas de la matriz.">ncol</a>; ++y)
<a name="l00289"></a>00289             fila[y] = 0;
<a name="l00290"></a>00290 
<a name="l00291"></a>00291         <span class="keywordflow">while</span>(<a class="code" href="sp__packcol_8c.html#49b361aae383b0fd323f5735f0ff01bc" title="Implementa un mecanismo eficiente para recorrer por filas una matriz dispersa empaquetada...">row_traversal_packcol</a>(A, &amp;i, &amp;j, &amp;posij) != -1)
<a name="l00292"></a>00292             fila[j] = A-&gt;<a class="code" href="structsp__packcol.html#6315b3a8ee78ac66aaae5ba79bda252e" title="Arreglo de valores por debajo de la diagonal.">val</a>[posij];
<a name="l00293"></a>00293 
<a name="l00294"></a>00294         <span class="keywordflow">for</span> (y=0; y &lt; A-&gt;<a class="code" href="structsp__packcol.html#2cc24559101ca3783f1949c8eebacd7c" title="Cantidad de columnas de la matriz.">ncol</a>; ++y)
<a name="l00295"></a>00295             fprintf(fp, <span class="stringliteral">" %g"</span>, fila[y]);
<a name="l00296"></a>00296 
<a name="l00297"></a>00297         <span class="keywordflow">if</span> (x+1 &lt; A-&gt;<a class="code" href="structsp__packcol.html#2e12b2881843b0ff8191f0654570a748" title="Cantidad de filas de la matriz.">nrow</a>)
<a name="l00298"></a>00298             fprintf(fp, <span class="stringliteral">";\n"</span>);
<a name="l00299"></a>00299         <span class="keywordflow">else</span>
<a name="l00300"></a>00300             fprintf(fp, <span class="stringliteral">"\n"</span>);
<a name="l00301"></a>00301     }
<a name="l00302"></a>00302 
<a name="l00303"></a>00303     fprintf(fp, <span class="stringliteral">"]\n"</span>);
<a name="l00304"></a>00304 
<a name="l00305"></a>00305     free(fila);
<a name="l00306"></a>00306 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b4d4d490381b43a9628f2001bb6c99d6"></a><!-- doxytag: member="sp_packcol.c::sp_imprimir_packcol" ref="b4d4d490381b43a9628f2001bb6c99d6" args="(FILE *fp, sp_packcol *mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sp_imprimir_packcol           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsp__packcol.html">sp_packcol</a> *&nbsp;</td>
          <td class="paramname"> <em>mat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Imprime la matriz guardada en formato empaquetado por columna en <code>fp</code>. 
<p>
<dl compact><dt><b>Parámetros:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>Archivo en el cual se imprimirá la matriz </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>Matriz a imprimir en formato empaquetado por columna</td></tr>
  </table>
</dl>
<b>NOTA:</b> Ver el código (5.4) en el paper de Stewart (vea las referencias). 
<p>Definición en la línea <a class="el" href="sp__packcol_8c-source.html#l00125">125</a> del archivo <a class="el" href="sp__packcol_8c-source.html">sp_packcol.c</a>.</p>

<p>Hace referencia a <a class="el" href="sp__packcol_8h-source.html#l00026">sp_packcol::colp</a>, <a class="el" href="sp__packcol_8h-source.html#l00024">sp_packcol::ncol</a>, <a class="el" href="sp__packcol_8h-source.html#l00025">sp_packcol::nnz</a>, <a class="el" href="sp__packcol_8h-source.html#l00023">sp_packcol::nrow</a>, <a class="el" href="sp__packcol_8h-source.html#l00027">sp_packcol::rx</a>, y <a class="el" href="sp__packcol_8h-source.html#l00028">sp_packcol::val</a>.</p>

<p>Referenciado por <a class="el" href="bal_8c-source.html#l00112">bal_imprimir_packcol()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00126"></a>00126 {
<a name="l00127"></a>00127     <span class="keywordtype">int</span> i, j;
<a name="l00128"></a>00128 
<a name="l00129"></a>00129     <span class="keywordflow">if</span> (mat == NULL) {
<a name="l00130"></a>00130         fprintf(fp, <span class="stringliteral">"Matriz nula.\n"</span>);
<a name="l00131"></a>00131         <span class="keywordflow">return</span>;
<a name="l00132"></a>00132     }
<a name="l00133"></a>00133 
<a name="l00134"></a>00134     fprintf(fp, <span class="stringliteral">"Cantidad de filas: %d\n"</span>, mat-&gt;<a class="code" href="structsp__packcol.html#2e12b2881843b0ff8191f0654570a748" title="Cantidad de filas de la matriz.">nrow</a>);
<a name="l00135"></a>00135     fprintf(fp, <span class="stringliteral">"Cantidad de columnas: %d\n"</span>, mat-&gt;<a class="code" href="structsp__packcol.html#2cc24559101ca3783f1949c8eebacd7c" title="Cantidad de columnas de la matriz.">ncol</a>);
<a name="l00136"></a>00136     fprintf(fp, <span class="stringliteral">"Cantidad de elementos no cero: %d\n"</span>, mat-&gt;<a class="code" href="structsp__packcol.html#667202fa30dd3d49982e3b0c8148bde4" title="Cantidad de elementos no cero.">nnz</a>);
<a name="l00137"></a>00137 
<a name="l00138"></a>00138     fprintf(fp, <span class="stringliteral">"Inicios de columnas:\n"</span>);
<a name="l00139"></a>00139     <span class="keywordflow">for</span>(i=0; i &lt;= mat-&gt;<a class="code" href="structsp__packcol.html#2cc24559101ca3783f1949c8eebacd7c" title="Cantidad de columnas de la matriz.">ncol</a>; ++i) {
<a name="l00140"></a>00140         fprintf(fp, <span class="stringliteral">"%d "</span>, mat-&gt;<a class="code" href="structsp__packcol.html#c9a9e31c6b9c1416fff29944568ea18f" title="Arreglo de punteros a los inicios de las columnas.">colp</a>[i]);
<a name="l00141"></a>00141     }
<a name="l00142"></a>00142     fprintf(fp, <span class="stringliteral">"\n"</span>);
<a name="l00143"></a>00143 
<a name="l00144"></a>00144     fprintf(fp, <span class="stringliteral">"Indices de filas:\n"</span>);
<a name="l00145"></a>00145     <span class="keywordflow">for</span>(i=0; i &lt; mat-&gt;<a class="code" href="structsp__packcol.html#667202fa30dd3d49982e3b0c8148bde4" title="Cantidad de elementos no cero.">nnz</a>; ++i) {
<a name="l00146"></a>00146         fprintf(fp, <span class="stringliteral">"%d "</span>, mat-&gt;<a class="code" href="structsp__packcol.html#536659b700c3b21fd5d6cf8538c82b6f" title="Arreglo de indices de fila.">rx</a>[i]);
<a name="l00147"></a>00147     }
<a name="l00148"></a>00148     fprintf(fp, <span class="stringliteral">"\n"</span>);
<a name="l00149"></a>00149 
<a name="l00150"></a>00150     fprintf(fp, <span class="stringliteral">"Valores:\n"</span>);
<a name="l00151"></a>00151     <span class="keywordflow">for</span>(i=0; i &lt; mat-&gt;<a class="code" href="structsp__packcol.html#667202fa30dd3d49982e3b0c8148bde4" title="Cantidad de elementos no cero.">nnz</a>; ++i) {
<a name="l00152"></a>00152         fprintf(fp, <span class="stringliteral">"%g "</span>, mat-&gt;<a class="code" href="structsp__packcol.html#6315b3a8ee78ac66aaae5ba79bda252e" title="Arreglo de valores por debajo de la diagonal.">val</a>[i]);
<a name="l00153"></a>00153     }
<a name="l00154"></a>00154     fprintf(fp, <span class="stringliteral">"\n"</span>);
<a name="l00155"></a>00155 
<a name="l00156"></a>00156     fprintf(fp, <span class="stringliteral">"Salida indexada (por columna):\n"</span>);
<a name="l00157"></a>00157     i=0;
<a name="l00158"></a>00158     <span class="keywordflow">for</span>(j=0; j &lt; mat-&gt;<a class="code" href="structsp__packcol.html#2cc24559101ca3783f1949c8eebacd7c" title="Cantidad de columnas de la matriz.">ncol</a>; ++j) {
<a name="l00159"></a>00159         <span class="keywordflow">for</span> (i = mat-&gt;<a class="code" href="structsp__packcol.html#c9a9e31c6b9c1416fff29944568ea18f" title="Arreglo de punteros a los inicios de las columnas.">colp</a>[j]; i &lt; mat-&gt;colp[j+1]; ++i) {
<a name="l00160"></a>00160             fprintf(fp, <span class="stringliteral">"(%d) [%d,%d] = %g\n"</span>, i, mat-&gt;<a class="code" href="structsp__packcol.html#536659b700c3b21fd5d6cf8538c82b6f" title="Arreglo de indices de fila.">rx</a>[i], j, mat-&gt;<a class="code" href="structsp__packcol.html#6315b3a8ee78ac66aaae5ba79bda252e" title="Arreglo de valores por debajo de la diagonal.">val</a>[i]);
<a name="l00161"></a>00161         }
<a name="l00162"></a>00162     }
<a name="l00163"></a>00163 }
</pre></div>
<p>

</div>
</div><p>
</div>
<hr size="1">
<address style="text-align: right;">
<small>BAL&nbsp;1.0.0<br>Generado el Wed Aug 27 19:54:18 2008.</small>
</address>
</body>
</html>
